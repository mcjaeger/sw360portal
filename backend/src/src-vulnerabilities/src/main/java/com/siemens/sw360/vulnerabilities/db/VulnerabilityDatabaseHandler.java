/*
 * Copyright Siemens AG, 2016. Part of the SW360 Portal Project.
 *
 * This program is free software; you can redistribute it and/or modify it under
 * the terms of the GNU General Public License Version 2.0 as published by the
 * Free Software Foundation with classpath exception.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License version 2.0 for
 * more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * this program (please see the COPYING file); if not, write to the Free
 * Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 * 02110-1301, USA.
 */
package com.siemens.sw360.vulnerabilities.db;

import com.siemens.sw360.datahandler.couchdb.DatabaseConnector;
import com.siemens.sw360.datahandler.thrift.RequestStatus;
import com.siemens.sw360.datahandler.thrift.users.User;
import com.siemens.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import com.siemens.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import com.siemens.sw360.vulnerabilities.common.VulnerabilityMapper;
import org.apache.commons.lang.StringUtils;
import org.apache.log4j.Logger;
import org.apache.thrift.TBase;

import java.net.MalformedURLException;
import java.util.Collection;
import java.util.List;
import java.util.Set;

/**
 * Class for accessing the CouchDB database
 *
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityDatabaseHandler {

    private static final Logger log = Logger.getLogger(VulnerabilityDatabaseHandler.class);

    /**
     * Connection to the couchDB database
     */
    protected DatabaseConnector db;
    private VulnerabilityRepository vulRepo;
    private VulnerabilityRelationRepository relationRepo;

    public VulnerabilityDatabaseHandler(String url, String dbName) throws MalformedURLException {
        // Create the connector
        db = new DatabaseConnector(url, dbName);
        vulRepo = new VulnerabilityRepository(db);
        relationRepo = new VulnerabilityRelationRepository(db);
    }

    public <T extends TBase> RequestStatus add(T element){
        if (element == null){
            log.error("cannot add null element");
            return RequestStatus.FAILURE;
        }
        log.debug("adding element "+element.toString());
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass()))
                vulRepo.add((Vulnerability) element);
            else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass()))
                relationRepo.add((ReleaseVulnerabilityRelation) element);
            else
                throw new IllegalArgumentException("unknown type "+ element.getClass().getSimpleName());
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on adding "+element.getClass().getSimpleName()+": "+e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus add(Class<T> type, Collection<T> elements) {
        if (type == null || elements == null) {
            log.error("type/elements cannot be null");
            return RequestStatus.FAILURE;
        }
        try {
            log.debug("adding "+elements.size()+" elements via bulk");
            if (Vulnerability.class.isAssignableFrom(type)) {
                vulRepo.executeBulk(elements);
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
                relationRepo.executeBulk(elements);
            } else
                throw new IllegalArgumentException("unknown type " + type.getSimpleName());

            log.debug("adding "+elements.size()+" elements via bulk finished");
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on bulk updating " + type.getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus update(T element){
        if (element == null){
            log.error("cannot update null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())){
                vulRepo.update(VulnerabilityMapper.setLastUpdate((Vulnerability) element));
            } else
                throw new IllegalArgumentException("unknown type "+ element.getClass().getSimpleName());

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on updating "+element.getClass().getSimpleName()+": "+e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus update(Collection<T> elements){
        if (elements != null && elements.size() > 0){
            return elements.stream()
                            .map(this::update)
                            .reduce(RequestStatus.SUCCESS, (r1, r2) -> {
                                if (r1 == RequestStatus.SUCCESS && r2 == RequestStatus.SUCCESS) {
                                    return RequestStatus.SUCCESS;
                                } else return RequestStatus.FAILURE;
                            });
        }
        return RequestStatus.SUCCESS;
    }

    public <T extends TBase> RequestStatus delete(T element){
        if (element == null){
            log.error("cannot remove null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass()))
                vulRepo.remove((Vulnerability) element);
            else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass()))
                relationRepo.remove((ReleaseVulnerabilityRelation) element);
            else
                throw new IllegalArgumentException("unknown type "+ element.getClass().getSimpleName());

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on removing "+element.getClass().getSimpleName()+": "+e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> List<T> getAll(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type))
            return (List<T>) vulRepo.getAll();
        else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type))
            return (List<T>) relationRepo.getAll();
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

    public <T extends TBase> Set<String> getAllIds(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type))
            return (Set<String>) vulRepo.getAllIds();
        else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type))
            return (Set<String>) relationRepo.getAllIds();
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

    public <T extends TBase> T getById(Class<T> type, String id){
        if (type == null || StringUtils.isEmpty(id)){
            log.error("type/id cannot be null "+type+" "+id);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (T) vulRepo.get(id);
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (T) relationRepo.get(id);
        }
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

    public <T extends TBase> Set<String> getAllExternalIds(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type))
            return (Set<String>) vulRepo.getAllExternalIds();
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

    public ReleaseVulnerabilityRelation getRelationByIds(String releaseId, String vulnerabilityId){
        if (StringUtils.isEmpty(releaseId) || StringUtils.isEmpty(vulnerabilityId)){
            log.error("releaseId/vulnerabilityId cannot be null "+releaseId+" "+vulnerabilityId);
            return null;
        }
        return relationRepo.getReletionByIds(releaseId, vulnerabilityId);
    }

    public List<ReleaseVulnerabilityRelation> getRelationsByReleaseIds(Collection<String> releaseIds){
        if (releaseIds == null || releaseIds.isEmpty()){
            log.error("releaseIds cannot be null/empty");
            return null;
        }
        return relationRepo.getRelationsByReleaseIds(releaseIds);
    }

    public List<ReleaseVulnerabilityRelation> getRelationsByVulnerabilityIds(Collection<String> vulnerabilityIds){
        if (vulnerabilityIds == null || vulnerabilityIds.isEmpty()){
            log.error("vulnerabilityIds cannot be null/empty");
            return null;
        }
        return relationRepo.getRelationsByVulnerabilityIds(vulnerabilityIds);
    }

    public <T extends TBase> T getByExternalId(Class<T> type, String externalId){
        if (type == null || StringUtils.isEmpty(externalId)){
            log.error("type/externalId cannot be null "+type+" "+externalId);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type))
            return (T) vulRepo.getVulnerabilityByExternalid(externalId);
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

    public <T extends TBase> T getLastUpdated(Class<T> type){
        if (type == null){
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type))
            return (T) vulRepo.getVulnerabilityByLastUpdate(null);
        else
            throw new IllegalArgumentException("unknown type "+ type.getSimpleName());
    }

}
